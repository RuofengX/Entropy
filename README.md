# Entropy | 熵

Rust Game. 一个Rust小游戏。

---

## 入门

欢迎游玩Entropy！
目前游戏以HTTP API的格式提供服务，Python SDK以及更多客户端正在开发中。

首先，你需要连接到游戏服务器，并注册一个账号。

## 注册
### 端点
`POST /player` 

### 请求内容
请求不需要鉴权；请求需附带json格式的参数表，详情如下：
| 参数名   | 类型   | 描述   |
| -------- | ------ | ------ |
| name     | String | 用户名 |
| password | String | 密码   |

### 返回内容
不出意外的话，服务器返回状态码200，附带内容为一个玩家对象的所有信息，格式为json：
| 返回值   | 类型   | 描述                       |
| -------- | ------ | -------------------------- |
| id       | int    | 身份号，用以登陆的唯一编号 |
| name     | String | 用户名，对外展示的名字     |
| password | String | 密码                       |


### 例子
使用`helloworld`作为用户名，`123456`作为密码（仅仅演示用，非常不推荐简单的密码）注册一个账号，则：对`/player`端点`POST`方法发起请求，并附带信息Body：
```json
{
    "name": "helloworld",
    "password": "helloworld"
}
```
服务器返回状态码200，并返回内容：
```json
{
    "id": 449,
    "name": "helloworld",
    "password": "helloworld"

}
```
服务器返回的ID和密码请一定记录好，这就是登入的唯一凭证。

## 获取玩家信息🔒
## 端点
`GET /player`   
是的没错，和注册是同一个端口，但是请求方法变为了`GET`。  
这是一个需要鉴权的接口，在请求的同时需要提供用户ID和密码，否则服务器将返回400错误

### 鉴权相关
服务器采用HTTP协议的Basic基础鉴权方案，在每一次请求中附带用户ID和密码，如果访问需要鉴权的接口但未提供相应的信息时，服务器会返回400错误。  
关于更多鉴权请参阅[MDN的文档](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Authentication)

### 请求内容
GET请求无需附带请求体，鉴权内容中已附带玩家账号信息
### 返回内容
如果鉴权成功，则返回玩家的所有信息

| 返回值   | 类型   | 描述                       |
| -------- | ------ | -------------------------- |
| id       | int    | 身份号，用以登陆的唯一编号 |
| name     | String | 用户名，对外展示的名字     |
| password | String | 密码                       |

返回内容与同URI的POST方法接口完全一致，这都是数据库玩家表包含的字段

## 创建第一个Guest
人生旅程，皆为过客。一个玩家可以控制多个实体角色，在Entropy游戏中，这些实体被称作**Guest**，这个特殊称谓取代了Character，一定程度上减小了代码量，同时也是参考了虚拟机系统中的Server-Client-Guest的三级名称。

一个玩家注册时是没有控制Guest的，常识地讲，玩家需要一个Guest来进行游玩，为此需要访问`/player/guest/spawn`端口，这个端口也是需要使用ID和密码鉴权的。

### 端点
`GET /player/guest/spawn`

我们从`/player`深入，来到了`/player/guest`，这代表着玩家的Guest操作，创建操作被命名为spawn，似乎很常规

### 请求内容
GET请求无需附带请求体，鉴权内容中已附带玩家账号信息

### 返回内容
如果鉴权成功，则立即创建一个Guest，并将这个Guest的主人设置为请求的玩家，完成这一切后返回新创建的Guest的信息。

每个玩家通过这个端点创生的第一个Guest是**免费的**，没有任何开销。但这样的spawn也只有一次机会。
如果玩家在已有guest的情况下再次调用这个端点，则会报错。  
稍后会介绍其他创建更多Guest的方法。

| 返回值      | 类型      | 描述                                      |
| ----------- | --------- | ----------------------------------------- |
| id          | int       | Guest的身份号，用以查询、控制等的唯一编号 |
| energy      | int       | 能量，一种收集物                          |
| pos         | (int,int) | Guest的位置，一个二维坐标                 |
| temperature | int       | Guest的温度，一种状态                     |
| master_id   | int       | Guest的拥有者的ID，对应了玩家ID           |

下面将会介绍游戏的GRID系统

## 游戏的坐标，GRID
GRID这个名字灵感来源于《创：战纪》中的*电子世界网络*，类似的用法还有*国家电网 State Grid*。
而实际上这个名字的意思就是一个坐标系统——平面直角坐标系。

Entropy的世界是二维的，拥有*x*和*y*两个维度，但是在数据库中的存储并不是两个字段（主要原因是Sea-ORM对pgsql的二维索引并不友好），所以干脆直接
将两个维度压缩为一个扁平维度进行存储，在对网络服务的时候由定制的序列化策略，在对坐标序列化时将低维度的索引转换为二维的坐标（这样做的缺点是不支持数据库空间索引，但Sea-ORM本来就不支持二维索引）。

虽然上面转换的过程看起来很复杂，但是不要紧，坐标系统本身其实很简单。

### 世界地图与节点

#### 节点
首先，整个世界是一个二维的梯度平面，世界由很多节点*Node*构成。每一个Node有两个属性。一个是坐标索引，是二维数组(i16,i16)；另一个是节点值，是一个不定长的数组Vec<u8>，最长不超过1024，长度全随机。代码就像这样：

```rust
struct NodeID(i16, i16); // 二维空间坐标

struct Node{ // 这是一个Node
    id: NodeID,
    data: Vec<u8>, // 节点包含许多Cell
}

struct FlatID(i32); // 压缩后的扁平索引，用以数据库存储
```

为了交流方便，就将节点中数据数组的一个特定数值称之为单元Cell。  
Cell既是一个字节，也是一个1位宽的无符号整数，Entropy游戏中一个Cell的值就被认为是这个Cell的温度。由此引出主题：

**玩家通过Guest和Cell的温度差进行发电，收集能量；消耗能量，不断增殖**

- 玩家控制Guest只能访问与其同节点上的Cell进行发电
- 发电的效率为卡诺热机的理论效率[^1]，关于卡诺循环详见[知乎专栏](https://zhuanlan.zhihu.com/p/514761818)
- 经过效率折算后，收集能量与温度转换的比例是1:1，也就是1点温度差等价于1点温度
- 小数部分在对玩家收获能量时向下取整，另一部分向上取整，总和不变

[^1]: 虽然Entropy的概念设计中不涉及内能与体积，但是效率依然选择了经典的卡诺循环效率。

#### 坐标与移动系统

WIP
